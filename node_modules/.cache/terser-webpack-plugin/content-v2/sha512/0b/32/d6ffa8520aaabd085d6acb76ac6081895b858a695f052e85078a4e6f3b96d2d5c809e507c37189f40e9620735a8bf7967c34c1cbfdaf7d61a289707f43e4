{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[158],{642:function(r,a,e){\"use strict\";e.r(a);var t=e(0),v=Object(t.a)({},(function(){var r=this,a=r.$createElement,e=r._self._c||a;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":r.$parent.slotKey}},[e(\"h2\",{attrs:{id:\"可靠性保证\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#可靠性保证\"}},[r._v(\"#\")]),r._v(\" 可靠性保证\")]),r._v(\" \"),e(\"p\",[r._v(\"可靠性保证指的是指确保系统在各种不同的环境下能够发生一致的行为\")]),r._v(\" \"),e(\"p\",[e(\"br\"),r._v(\"\\nKafka的保证机制有：\")]),r._v(\" \"),e(\"ul\",[e(\"li\",[r._v(\"Kafka可以保证分区消息的顺序。如果使用同一个生产者往同一个分区写入消息，而且消息B在消息A之后写入，那么Kafka可以保证消息B的偏移量比消息A的偏移量大，而且消费者会先读取消息A再读取消息B\")]),r._v(\" \"),e(\"li\",[r._v('只有当消息被写入分区的所有同步副本时（但不一定要写入磁盘），它才被认为是\"已提交\"的。生产者可以选择接收不同类型的确认，比如在消息被完全提交时的确认，或者在消息被写入首领副本时的确认，或者在消息被发送到网络时的确认')]),r._v(\" \"),e(\"li\",[r._v(\"只要还有一个副本是活跃的，那么已经提交的消息就不会丢失\")]),r._v(\" \"),e(\"li\",[r._v(\"消费者只能读取已经提交的消息\")])]),r._v(\" \"),e(\"p\",[r._v(\"这些基本的保证机制可以用来构建可靠的系统，但仅仅依赖它们是无法保证系统完全可靠的。构建一个可靠的系统需要作出一些权衡，Kafka管理员和开发者可以在配置参数上作出权衡，从而得到他们想要达到的可靠性。这种权衡一般是指消息存储的可靠性和一致性的重要程度与可用性、高吞吐量、低延迟和硬件成本的重要程度之间的权衡\")]),r._v(\" \"),e(\"h2\",{attrs:{id:\"复制\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#复制\"}},[r._v(\"#\")]),r._v(\" 复制\")]),r._v(\" \"),e(\"p\",[r._v(\"Kafka的复制机制和分区的多副本架构是Kafka可靠性保证的核心。把消息写入多个副本可以使Kafka在发生崩溃时仍能保证消息的持久性。Kafka的主题被分为多个分区，分区是基本的数据块。分区存储在单个磁盘上，Kafka可以保证分区里的事件是有序的，分区可以在线（可用），也可以离线（不可用）。每个分区可以有多个副本，其中一个副本是首领。所有的事件都直接发送给首领副本，或者直接从首领副本读取事件。其他副本只需要与首领保持同步，并及时复制最新的事件。当首领副本不可用时，其中一个同步副本将成为新首领\")]),r._v(\" \"),e(\"p\",[e(\"br\"),r._v(\"\\n分区首领是同步副本，而对于跟随者副本来说，它需要满足以下条件才能被认为是同步的:\")]),r._v(\" \"),e(\"ul\",[e(\"li\",[r._v(\"与Zookeeper之间有一个活跃的会话，也就是说，它在过去的6s（可配置）内向Zookeeper发送过心跳\")]),r._v(\" \"),e(\"li\",[r._v(\"在过去的10s内（可配置）从首领那里获取过消息\")]),r._v(\" \"),e(\"li\",[r._v(\"在过去的10s内从首领那里获取过最新的消息。光从首领那里获取消息是不够的，它还必须是几乎零延迟的\")])]),r._v(\" \"),e(\"p\",[r._v(\"一个滞后的同步副本会导致生产者和消费者变慢，因为在消息被认为已提交之前，客户端会等待所有同步副本接收消息。而如果一个副本不再同步了，我们就不再关心它是否已经收到消息。虽然非同步副本同样滞后，但它并不会对性能产生任何影响。但是，更少的同步副本意味着更低的有效复制系数，在发生岩机时丢失数据的风险更大\")]),r._v(\" \"),e(\"h2\",{attrs:{id:\"broker配置\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#broker配置\"}},[r._v(\"#\")]),r._v(\" broker配置\")]),r._v(\" \"),e(\"p\",[r._v(\"broker有3个配置参数会影响Kafka消息存储的可靠性。与其他配置参数一样，它们可以应用在broker级别，用于控制所有主题的行为，也可以应用在主题级别，用于控制个别主题的行为\")]),r._v(\" \"),e(\"h3\",{attrs:{id:\"复制系数\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#复制系数\"}},[r._v(\"#\")]),r._v(\" 复制系数\")]),r._v(\" \"),e(\"p\",[r._v(\"主题级别的配置参数是replication.factor，而在broker级别则可以通过default.replication.factor来配置自动创建的主题。Kafka的默认复制系数是3。如果复制系数为N，那么在N-l个broker失效的情况下，仍然能够从主题读取数据或向主题写入数据。所以，更高的复制系数会带来更高的可用性、可靠性和更少的故障。另一方面，复制系数N需要至少N个broker，而且会有N个数据副本，也就是说它们会占用N倍的磁盘空间。这就需要我们在可用性和存储硬件之间作出权衡\")]),r._v(\" \"),e(\"p\",[e(\"br\"),r._v(\"\\n副本的分布也很重要。默认情况下，Kafka会确保分区的每个副本被放在不同的broker上。不过，有时候这样仍然不够安全。如果这些broker处于同一个机架上，一旦机架的交换机发生故障，分区就会不可用，这时候把复制系数设为多少都不管用。为了避免机架级别的故障，我们建议把broker分布在多个不同的机架上，并使用broker.ack 参数来为每个broker配置所在机架的名字。如果配置了机架名字，Kafka会保证分区的副本被分布在多个机架上，从而获得更高的可用性\")]),r._v(\" \"),e(\"h3\",{attrs:{id:\"不完全的首领选举\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#不完全的首领选举\"}},[r._v(\"#\")]),r._v(\" 不完全的首领选举\")]),r._v(\" \"),e(\"p\",[r._v(\"unclean.leader.election只能在broker级别（实际上是在集群范围内）进行配置，它的默认值是true。表示果在首领不可用时但其他副本都是不同步的情况下，允许选举其它的不同步副本为首领。如果我们允许不同步的副本成为首领，那么就要承担丢失数据和出现数据不一致的风险。如果不允许它们成为首领，那么就要接受较低的可用性，因为我们必须等待原先的首领恢复到可用状态\")]),r._v(\" \"),e(\"h3\",{attrs:{id:\"最少同步副本\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#最少同步副本\"}},[r._v(\"#\")]),r._v(\" 最少同步副本\")]),r._v(\" \"),e(\"p\",[r._v(\"在主题级别和broker级别上，这个参数都叫min.insync.replicas。假设一个主题有3个副本，我们设置min.insync.replicas的值为2，那么至少要存在两个同步副本才能向分区写入数据。如果3个副本都是同步的，或者其中一个副本变为不可用，都不会有什么问题。不过，如果有两个副本变为不可用，那么broker就会停止接受生产者的请求。尝试发送数据的生产者会收到NotEnoughReplicasException异常。消费者仍然可以继续读取已有的数据。实际上，如果使用这样的配置，那么当只剩下一个同步副本时，它就变成只读了，这是为了避免在发生不完全选举时数据的写入和读取出现非预期的行为。为了从只读状态中恢复，必须让两个不可用分区中的一个重新变为可用的（比如重启broker），并等待它变为同步的\")])])}),[],!1,null,null,null);a.default=v.exports}}]);","extractedComments":[]}