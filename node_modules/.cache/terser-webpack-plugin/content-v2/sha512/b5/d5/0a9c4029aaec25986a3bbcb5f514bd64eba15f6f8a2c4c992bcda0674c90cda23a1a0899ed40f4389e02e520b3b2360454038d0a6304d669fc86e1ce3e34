{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{610:function(v,_,t){\"use strict\";t.r(_);var a=t(0),r=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[t(\"blockquote\",[t(\"p\",[v._v(\"如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误，有三种方式可以修复这个问题：\")]),v._v(\" \"),t(\"ul\",[t(\"li\",[v._v(\"不在线程之间共享该状态变量\")]),v._v(\" \"),t(\"li\",[v._v(\"将状态变量修复为不可变的变量\")]),v._v(\" \"),t(\"li\",[v._v(\"在访问状态变量时使用同步\")])]),v._v(\" \"),t(\"p\",[v._v(\"当设计线程安全的类时，良好的面向对象技术、不可修改性以及明晰的不变性规范都能起到一定的帮助作用\")])]),v._v(\" \"),t(\"h2\",{attrs:{id:\"什么是线程安全性\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#什么是线程安全性\"}},[v._v(\"#\")]),v._v(\" 什么是线程安全性\")]),v._v(\" \"),t(\"p\",[v._v(\"当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何调度执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的\")]),v._v(\" \"),t(\"p\",[v._v(\"无状态对象一定是线程安全的\")]),v._v(\" \"),t(\"hr\"),v._v(\" \"),t(\"h2\",{attrs:{id:\"原子性\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#原子性\"}},[v._v(\"#\")]),v._v(\" 原子性\")]),v._v(\" \"),t(\"p\",[v._v('由于不恰当的执行时序而出现不正确的执行结果是一种非常重要的情况，这种情况称为竞态条件。当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。换句话说，就是正确的结果要取决于运气。最常见的竞态条件类型就是\"先检查后执行操作\"，即通过一个可能失效的观测结果来决定下一步的动作')]),v._v(\" \"),t(\"p\",[v._v(\"假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。原子操作是指，对于访问同一个状态的所有操作（包括操作本身）来说，这个操作是一个以原子方式执行的操作\")]),v._v(\" \"),t(\"h2\",{attrs:{id:\"加锁机制\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#加锁机制\"}},[v._v(\"#\")]),v._v(\" 加锁机制\")]),v._v(\" \"),t(\"p\",[v._v(\"要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量\")]),v._v(\" \"),t(\"p\",[t(\"strong\",[v._v(\"内置锁\")]),t(\"br\"),v._v(\"\\nJava提供了一种内置的锁机制来支持原子性：同步代码块。同步代码块包括两部分：一个作为锁的对象应用，一个作为由这个锁保护的代码块。以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块。其中该同步代码块的锁就是方法调用的所在对象。静态的synchronized方法就是以Class对象为锁\"),t(\"br\"),v._v(\"\\nsynchronized(lock){\\n//访问或修改由锁保护的共享状态\\n}\")]),v._v(\" \"),t(\"p\",[v._v(\"每个Java对象都可以用作一个实现同步的锁，这些锁被称为内置锁或监视器锁。线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁，而无论是通过正常的控制路径退出，还是从通过代码块中抛出异常退出。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法\")]),v._v(\" \"),t(\"p\",[v._v(\"Java的内置锁相当于一种互斥体（或互斥锁），这意味着最多只有一个线程能持有这种锁。当线程A尝试获取一个由线程B持有的锁时，线程A必须等待或阻塞，直到线程B释放这个锁，如果B永远不释放锁，那么A也将永远的等待下去\")]),v._v(\" \"),t(\"p\",[v._v(\"由于每次只能有一个线程执行内置锁保护的代码块，因此，由这个锁保护的代码块会以原子的方式执行，多个线程在执行该代码时也不会相互干扰。并发环境中的原子性与事务应用程序中的原子性有着相同的含义--一组语句作为一个不可分割的单元被执行。任何一个执行同步代码块的线程，都不可能看到有其它线程正在执行由同一个锁保护的代码块\")]),v._v(\" \"),t(\"p\",[t(\"strong\",[v._v(\"重入\")]),t(\"br\"),v._v('\\n当某个线程请求一个其它线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置锁是可重入的，因此如果某个线程尝试获得一个已经由它自己持有的锁，那么这个请求就会成功。\"重入\"意味着获取锁的操作粒度是\"线程\"，而不是\"调用\"。重入的一种实现方法是，为每个锁关联一个获取计数值和一个所有者线程。当技术值为0时，这个锁就认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下锁的持有者，并且将获取的计数值记为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器将会相应的递减，当计数值为0时，这个锁将被释放')]),v._v(\" \"),t(\"h2\",{attrs:{id:\"用锁来保护状态\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#用锁来保护状态\"}},[v._v(\"#\")]),v._v(\" 用锁来保护状态\")]),v._v(\" \"),t(\"p\",[v._v(\"由于锁能使其保护的代码路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问，只要始终遵循这些协议，就能确保状态的一致性\")]),v._v(\" \"),t(\"p\",[v._v(\"对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的\")]),v._v(\" \"),t(\"p\",[v._v(\"对象的内置锁与其状态之间没有内在的关联。虽然大多数类都将内置锁用作一种有效的加锁机制，但对象的域并不一定要通过内置锁来保护。当获取与对象关联的锁时，并不能阻止其它线程访问该对象，某个线程在获得对象的锁之后，只能组织其它线程获得同一个锁。之所以每个对象都有一个内置锁，只是为了免去显式的创建锁对象。你需要自行构造加锁协议或者同步策略来实现对共享状态的安全访问，并且在程序中自始至终地使用它们\")]),v._v(\" \"),t(\"p\",[v._v(\"一种常见的加锁约定是，将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问\")]),v._v(\" \"),t(\"h2\",{attrs:{id:\"用锁来保护状态-2\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#用锁来保护状态-2\"}},[v._v(\"#\")]),v._v(\" 用锁来保护状态\")]),v._v(\" \"),t(\"p\",[v._v(\"通常，在简单性与性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目地为了性能而牺牲简单性（着这可能会影响安全性）\")]),v._v(\" \"),t(\"p\",[v._v(\"当使用锁时，你应该清除代码块中实现的功能，以及在执行该代码块时是否需要很长的时间。无论是执行计算密集的操作，还是执行某个可能阻塞的操作，如果持有锁的时间过长，那么都会带来活跃性或性能问题\")]),v._v(\" \"),t(\"p\",[v._v(\"当执行时间较长的计算或者可能无法快速完成的操作时（例如，网络I/O或控制台I/O），一定不要持有锁\")])])}),[],!1,null,null,null);_.default=r.exports}}]);","extractedComments":[]}