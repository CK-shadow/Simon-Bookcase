{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{648:function(v,_,t){\"use strict\";t.r(_);var a=t(0),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[t(\"h2\",{attrs:{id:\"可见性\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#可见性\"}},[v._v(\"#\")]),v._v(\" 可见性\")]),v._v(\" \"),t(\"p\",[v._v(\"在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，想要对内存操作的执行顺序进行判断几乎无法得出正确的结论\")]),v._v(\" \"),t(\"p\",[v._v(\"在线程没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为最低安全性\")]),v._v(\" \"),t(\"p\",[v._v(\"加锁的含义不仅仅局限于互斥行为，还包括内存可见性，为了确保所有线程都能看到共享变量的最新值，所有执行读操作或写操作的线程都必须在同一个锁上同步\")]),v._v(\" \"),t(\"p\",[v._v(\"Java程序提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其它线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量时共享的，因此不会将该变量上的操作与其它内存操作一起重排序。volatile变量不会被缓存在寄存器或对其它处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值\")]),v._v(\" \"),t(\"p\",[v._v(\"加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性\")]),v._v(\" \"),t(\"p\",[v._v(\"当且仅当满足以下所有条件时，才应该使用volatile变量：\")]),v._v(\" \"),t(\"ul\",[t(\"li\",[v._v(\"对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值\")]),v._v(\" \"),t(\"li\",[v._v(\"该变量不会与其它状态变量一起纳入不变性条件\")]),v._v(\" \"),t(\"li\",[v._v(\"在访问变量时不需要加锁\")])]),v._v(\" \"),t(\"h2\",{attrs:{id:\"发布和逸出\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#发布和逸出\"}},[v._v(\"#\")]),v._v(\" 发布和逸出\")]),v._v(\" \"),t(\"p\",[v._v(\"发布对象意味着其作用域之外的代码可以访问操作此对象\\n逸出即为发布了本不该发布的对象\")]),v._v(\" \"),t(\"p\",[v._v(\"不要在构造过程中使this引用逸出\")]),v._v(\" \"),t(\"p\",[v._v(\"在构造过程中使this引用逸出的一个常见错误是，在构造函数中启动一个线程。当对象在其构造函数中创建一个线程时，无论是显式创建（通过将它传给构造函数）还是隐式创建（由于Thread和Runnable是该对象的一个内部类），this引用都会被新创建的线程共享。在对象尚未完全构造之前，新的线程就可以看见它。在构建函数中创建线程并没有什么错误，但最好不要立即启动它，而是通过一个start或initialize方法启动。在构造函数中调用一个可改写的实例方法时（既不是私有方法，也不是终结方法），同样会导致this引用在构造过程中逸出\")]),v._v(\" \"),t(\"h2\",{attrs:{id:\"线程封闭\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#线程封闭\"}},[v._v(\"#\")]),v._v(\" 线程封闭\")]),v._v(\" \"),t(\"p\",[v._v(\"当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据，如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭，它是实现线程安全性的最简单方式之一。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，就是被封闭的对象本身不是线程安全的\")]),v._v(\" \"),t(\"p\",[t(\"strong\",[v._v(\"Ad-hoc线程封闭\")]),t(\"br\"),v._v(\"\\nAd-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。Ad-hoc线程封闭是非常脆弱的，因为没有任何一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到目标线程上。由于Ad-hoc线程封闭技术的脆弱性，因此在程序中尽量少用它，在可能的情况下，应该使用更强的线程封闭技术\")]),v._v(\" \"),t(\"p\",[t(\"strong\",[v._v(\"栈封闭\")]),t(\"br\"),v._v(\"\\n栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。正如封装能使得代码更能维持不变性那样，同步变量也能使对象更易于封闭在线程中。局部变量的固有属性之一就是封闭在执行线程中，它们位于执行线程的栈中，其它线程无法访问这个栈\")]),v._v(\" \"),t(\"p\",[t(\"strong\",[v._v(\"ThreadLocal类\")]),t(\"br\"),v._v(\"\\n维持线程封闭性的一种更规范方法是使用ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来，ThreadLocal提供了get与set等访问接口或方法，这个接口为每个使用该方法的线程都存有一份独立的副本，因此get总是返回由当前执行线程在调用set设置的最新值\")]),v._v(\" \"),t(\"h2\",{attrs:{id:\"不变性\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#不变性\"}},[v._v(\"#\")]),v._v(\" 不变性\")]),v._v(\" \"),t(\"p\",[v._v(\"如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。线程安全性是不可变对象的固有属性之一，它们的不变性条件是由构造函数创建的，只要他们的状态不改变，那么这些不变性条件就能得以维持\")]),v._v(\" \"),t(\"p\",[v._v(\"不可变对象一定是线程安全的\")]),v._v(\" \"),t(\"p\",[v._v(\"当满足以下条件时，对象才是不可变的：\")]),v._v(\" \"),t(\"ul\",[t(\"li\",[v._v(\"对象创建以后其状态就不能修改\")]),v._v(\" \"),t(\"li\",[v._v(\"对象的所有域都是final类型\")]),v._v(\" \"),t(\"li\",[v._v(\"对象是正确创建的（在对象的创建期间，this引用没有逸出）\")])]),v._v(\" \"),t(\"p\",[v._v('正如\"除非需要更高的可见性，否则应将所有的域都声明为私有域\"是一个良好的编程习惯，除非需要某个域是可变的，否则应将其声明为final域也是一个良好的编程习惯')]),v._v(\" \"),t(\"h2\",{attrs:{id:\"安全发布\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#安全发布\"}},[v._v(\"#\")]),v._v(\" 安全发布\")]),v._v(\" \"),t(\"p\",[v._v(\"任何线程都可以在不需要额外同步的情况下安全的访问不可变对象，即使在发布这些对象时没有使用同步\")]),v._v(\" \"),t(\"p\",[v._v(\"要安全地发布一个对象，对象的引用以及对象的状态必须同时对其它线程可见，一个正确构造的对象可以通过以下方式来安全的发布：\")]),v._v(\" \"),t(\"ul\",[t(\"li\",[v._v(\"在静态初始化函数中初始化一个对象引用\")]),v._v(\" \"),t(\"li\",[v._v(\"将对象的引用保存到volatile对象的域或者AtomicReference对象中\")]),v._v(\" \"),t(\"li\",[v._v(\"将对象的引用保存到某个正确构造对象的final域中\")]),v._v(\" \"),t(\"li\",[v._v(\"将对象的引用保存到一个由锁保护的域中\")])]),v._v(\" \"),t(\"p\",[v._v('如果对象从技术上看是可变的，但其状态在发布后不会再改变，那么把这种对象称为\"事实不可变对象\"。在没有额外同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象')]),v._v(\" \"),t(\"p\",[v._v(\"对象的发布需求取决于它的可变性：\")]),v._v(\" \"),t(\"ul\",[t(\"li\",[v._v(\"不可变对象可以通过任意机制来发布\")]),v._v(\" \"),t(\"li\",[v._v(\"事实不可变对象必须通过安全方式来发布\")]),v._v(\" \"),t(\"li\",[v._v(\"可变对象必须通过安全方式来发布，并且必须是线程安全的或者由锁保护起来\")])]),v._v(\" \"),t(\"p\",[v._v(\"在并发程序中使用和共享对象时，可以使用一些实用的策略，例如：\")]),v._v(\" \"),t(\"ul\",[t(\"li\",[v._v(\"线程封闭：县城封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改\")]),v._v(\" \"),t(\"li\",[v._v(\"只读共享：在没有额外同步的情况下，共享的制度对象可以由多个线程并发访问，但任何线程都不能修改它，共享的只读对象包括不可变对象和事实不可变对象\")]),v._v(\" \"),t(\"li\",[v._v(\"线程安全共享：线程安全地对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问为不需要进一步的同步\")]),v._v(\" \"),t(\"li\",[v._v(\"保护对象：被保护的对象只能通过持有特定的锁来访问，保护对象包括封装在其它线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象\")])])])}),[],!1,null,null,null);_.default=l.exports}}]);","extractedComments":[]}