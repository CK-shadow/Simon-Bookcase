{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{360:function(t,n,e){t.exports=e.p+\"assets/img/201910301548.44d71e36.png\"},361:function(t,n,e){t.exports=e.p+\"assets/img/201910301705.c696b6fd.png\"},695:function(t,n,e){\"use strict\";e.r(n);var s=e(0),a=Object(s.a)({},(function(){var t=this,n=t.$createElement,s=t._self._c||n;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[s(\"h3\",{attrs:{id:\"maven依赖管理\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#maven依赖管理\"}},[t._v(\"#\")]),t._v(\" Maven依赖管理\")]),t._v(\" \"),s(\"p\",[t._v(\"Maven一个核心的特性就是依赖管理，当我们处理多模块的项目（包含成百上千个模块或子项目），模块间的依赖关系就变得非常复杂，管理也变得很困难。针对此种情形，Maven提供了一种高度控制的方法\")]),t._v(\" \"),s(\"p\",[s(\"strong\",[t._v(\"可传递性依赖发现\")]),s(\"br\"),t._v(\"\\n一种相当常见的情况，比如说A依赖于其它库B，如果，另一个项目C想要用A，那么C也需要使用B。Maven可以避免去搜索所有所需库的需求，Maven通过读取项目文件，找出它们项目之间的依赖关系。我们所需要做的至少在每个项目的pom中定义好直接的依赖关系，其它的事情Maven会帮我们搞定。通过可传递性的依赖，所有被包含的库的图形会快速的增长。当有重复库时，可能出现的清醒将会持续的上升，Maven提供一些功能来控制可传递的依赖的程度\")]),t._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:e(360),alt:\"\"}})]),t._v(\" \"),s(\"p\",[s(\"strong\",[t._v(\"依赖范围\")]),s(\"br\"),t._v(\"\\n传递依赖发现可以通过使用依赖范围来限制\")]),t._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:e(361),alt:\"\"}})]),t._v(\" \"),s(\"p\",[s(\"strong\",[t._v(\"依赖管理\")]),s(\"br\"),t._v(\"\\n通常情况下，在一个共通的目录下，有一系列的项目。在这种情况下，我们可以创建一个公共依赖的pom文件，该pom包含所有的公共的依赖关系，我们称其为其它子项目pom的父pom\")])])}),[],!1,null,null,null);n.default=a.exports}}]);","extractedComments":[]}