{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{733:function(t,v,o){\"use strict\";o.r(v);var r=o(0),_=Object(r.a)({},(function(){var t=this,v=t.$createElement,o=t._self._c||v;return o(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[o(\"h2\",{attrs:{id:\"命名风格\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#命名风格\"}},[t._v(\"#\")]),t._v(\" 命名风格\")]),t._v(\" \"),o(\"ol\",[o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 代码中的命名均不能以下划线或$开始，也不能以下划线或$结束\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 类名使用UpperCamelCase风格，但以下情形例外：DO/BO/DTO/VO/AO/PO/UID等\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从驼峰形式\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 常量名称全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾，测试类要以它测试的类名开始，\\n以Test结尾\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 类型中与括号紧挨相连表示数组\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" POJO类中布尔类型的变量，都不要加is前缀，否则部分框架解析会引起序列化错误\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词，包名统一使用单数形式，但是类名如\\n果有复数含义，类名可以使用复数形式\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 杜绝完全不规范的缩写，避免望文不知义\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 为了达到代码自解释的目的，任何自定义编程元素在命名时，尽量使用完整的单词组合来表达其意\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 如果模块、接口、类、方法使用了设计模式，在命名时需体现其具体模式\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 接口类中的属性和方法不要加任何修饰符号(public也不要加)，保持代码的简洁性，并加上有效的\\nJavadoc注释，尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个\\n应用的基础常量\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 接口和实现类命名有两套规则：\\n\"),o(\"ol\",[o(\"li\",[t._v(\"对于Service和Dao类，基于SOA理念，暴露出来的服务一定是接口，内部实现类用Impl后缀与接口区别\")]),t._v(\" \"),o(\"li\",[t._v(\"如果是形容能力的接口名称，取对应的形容词为接口名称(一般是-able的形式)\")])])],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"green\"}},[t._v(\"[参考]\")]),t._v(\" 枚举类名建议加上Enum后缀，枚举成员名称需全部大写，单词间用下划线隔开\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"green\"}},[t._v(\"[参考]\")]),t._v(\" 各层命名规约\\n\"),o(\"ul\",[o(\"li\",[t._v(\"Service/Dao层命名规约\\n\"),o(\"ol\",[o(\"li\",[t._v(\"获取单个对象的方法用get作为前缀\")]),t._v(\" \"),o(\"li\",[t._v(\"获取多个对象的方法用list作为前缀，复数形式结尾，如：listUsers\")]),t._v(\" \"),o(\"li\",[t._v(\"获取统计值的方法用count作为前缀\")]),t._v(\" \"),o(\"li\",[t._v(\"插入方法用save/insert作为前缀\")]),t._v(\" \"),o(\"li\",[t._v(\"删除方法用delete/remove作为前缀\")]),t._v(\" \"),o(\"li\",[t._v(\"修改方法用update作为前缀\")])])]),t._v(\" \"),o(\"li\",[t._v(\"领域模型命名规约\\n\"),o(\"ol\",[o(\"li\",[t._v(\"数据对象：xxxDO，xxx为数据表名\")]),t._v(\" \"),o(\"li\",[t._v(\"数据传输对象：xxxDTO，xxx为业务领域相关的名称\")]),t._v(\" \"),o(\"li\",[t._v(\"展示对象：xxxVO，xxx一般为网页名称\")]),t._v(\" \"),o(\"li\",[t._v(\"POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO\")])])])])],1)]),t._v(\" \"),o(\"hr\"),t._v(\" \"),o(\"h2\",{attrs:{id:\"常量定义\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#常量定义\"}},[t._v(\"#\")]),t._v(\" 常量定义\")]),t._v(\" \"),o(\"ol\",[o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 不允许任何魔法值(即未经预先定义的常量)直接出现在代码中\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 在long或Long赋值时，数值后使用大写的L，不能是小写的l，小写容易跟数字混淆，产生误解\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 不要使用一个常量类维护所有的常量，要按常量功能进行归类，分开维护\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 常量的复用层次有5层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量\\n\"),o(\"ol\",[o(\"li\",[t._v(\"跨应用共享常量：放置在二方库中，通常是client.jar中的constant目录下\")]),t._v(\" \"),o(\"li\",[t._v(\"应用内共享常量：放置在一方库中，通常是子模块中的constant目录下\")]),t._v(\" \"),o(\"li\",[t._v(\"子工程内部共享常量：即在当前子工程的constant目录下\")]),t._v(\" \"),o(\"li\",[t._v(\"包内共享常量：即在当前包下单独的constant目录下\")]),t._v(\" \"),o(\"li\",[t._v(\"类内共享常量：直接在类内部private static final定义\")])])],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 如果变量值仅在一个固定范围内变化用enum类型定义\")],1)]),t._v(\" \"),o(\"hr\"),t._v(\" \"),o(\"h2\",{attrs:{id:\"代码格式\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#代码格式\"}},[t._v(\"#\")]),t._v(\" 代码格式\")]),t._v(\" \"),o(\"ol\",[o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 大括号的使用约定。如果是大括号内为空，则简介的写成{}即可，不需要换行；如果是非空代码块则：\\n\"),o(\"ol\",[o(\"li\",[t._v(\"左大括号前不换行\")]),t._v(\" \"),o(\"li\",[t._v(\"右大括号后换行\")]),t._v(\" \"),o(\"li\",[t._v(\"右大括号前换行\")]),t._v(\" \"),o(\"li\",[t._v(\"右大括号后还有else等代码不换行；表示终止的右大括号后必须换行\")])])],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 左小括号与字符之间不出现空格，同样，右大括号与字符之间也不出现空格，而左边大括号前需要空格\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" if/for/while/switch/do等保留字与括号之间都必须加空格\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 任何二目、三目运算符的左右两边都需要加一个空格\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 采用4空格缩进，禁止使用tab字符\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 注释的双斜线与注释内容之间有且仅有一个空格\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 单行字符数限制不超过120个，超出需要换行，换行需遵循以下准则：\\n\"),o(\"ol\",[o(\"li\",[t._v(\"第二行与第一行之间缩进四个空格，从第三行开始，不再继续缩进\")]),t._v(\" \"),o(\"li\",[t._v(\"运算符与下文一起换行\")]),t._v(\" \"),o(\"li\",[t._v(\"方法调用的点符号与下文一起换行\")]),t._v(\" \"),o(\"li\",[t._v(\"方法调用的多个参数需要进行换行时，在逗号后进行\")]),t._v(\" \"),o(\"li\",[t._v(\"在括号前不要换行\")])])],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 方法参数在定义和传入时，多个参数逗号后必须加空格\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" IDE的text file encoding设置为UTF-8；IDE中文件的换行符使用Unix格式，不要使用Windows格式\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 单个方法的总行数不超过80行\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性\")],1)]),t._v(\" \"),o(\"hr\"),t._v(\" \"),o(\"h2\",{attrs:{id:\"oop规约\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#oop规约\"}},[t._v(\"#\")]),t._v(\" OOP规约\")]),t._v(\" \"),o(\"ol\",[o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问\\n即可\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 所有重写方法，必须加@Override注解\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 相同参数类型、相同业务含义，才可以使用Java的可变参数，避免使用Object\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 外部正在调用或二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响，接口过时必须添加\\n@Deprecated注解，并清晰地说明采用的新接口或新服务是什么\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 不能使用过时的类或方法\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 所有的相同类型的包装类对象之间值得比较，全部使用equals方法比较\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 关于基本数据类型和包装数据类型的使用标准如下：\\n\"),o(\"ol\",[o(\"li\",[t._v(\"所有的POJO类属性必须使用包装数据类型\")]),t._v(\" \"),o(\"li\",[t._v(\"RPC方法的参数和返回值必须使用包装数据类型\")]),t._v(\" \"),o(\"li\",[t._v(\"所有的局部变量使用基本数据类型\")])])],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 定义DO/DTO/VO等POJO类时，不要设定任何属性默认值\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 序列化类新增属性时，请不要修改serialVersionUID字段，避免反序列化失败；若如果完全不兼容升级，\\n避免反序列化混乱，那么请修改serialVersionUID字段\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 构造方法内禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" POJO类必须写toString方法\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 禁止在POJO类中，同时存在对应属性xxx的isXxx()和getXxx()方法\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 使用索引访问String的split方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛出下标越界异常的风险\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 当一个类有多个构造方法，或者多个重名方法，这些方法应该按顺序放置在一起\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 类内方法定义的顺序依次是：共有方法或保护方法 > 私有方法 > getter和setter方法\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" setter方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在getter/setter方法中，\\n不要增加业务逻辑，增加排查问题的难度\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 循环体内，字符串的连接方式，使用StringBuiler的append()方法进行拓展\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" final可以声明类、成员变量、方法以及本地变量，下列情况使用final关键字：\\n\"),o(\"ol\",[o(\"li\",[t._v(\"不允许被继承的类，比如String类\")]),t._v(\" \"),o(\"li\",[t._v(\"不允许修改引用的域对象\")]),t._v(\" \"),o(\"li\",[t._v(\"不允许被重写的方法，如POJO类的setter方法\")]),t._v(\" \"),o(\"li\",[t._v(\"不允许运行过程中重新赋值的局部变量\")]),t._v(\" \"),o(\"li\",[t._v(\"避免上下文重复使用一个变量，使用final描述可以强制重新定义一个变量，方便更好的进行重构\")])])],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 慎用Object的clone()方法拷贝对象\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 类成员与方法访问控制从严\\n\"),o(\"ol\",[o(\"li\",[t._v(\"如果不允许外部直接通过new来创造对象，那么构造方法必须是private\")]),t._v(\" \"),o(\"li\",[t._v(\"工具类不允许有public或default构造方法\")]),t._v(\" \"),o(\"li\",[t._v(\"类非static成员变量并且与子类分享，必须是protected\")]),t._v(\" \"),o(\"li\",[t._v(\"类非static成员变量并且仅在本类使用，必须是private\")]),t._v(\" \"),o(\"li\",[t._v(\"类static成员变量仅在本类使用，必须是private\")]),t._v(\" \"),o(\"li\",[t._v(\"若是static成员变量，考虑是否为final\")]),t._v(\" \"),o(\"li\",[t._v(\"类成员方法只供类内部调用，必须是private\")]),t._v(\" \"),o(\"li\",[t._v(\"类成员方法只对继承类公开，那么限制为protected\")])])],1)]),t._v(\" \"),o(\"hr\"),t._v(\" \"),o(\"h2\",{attrs:{id:\"集合处理\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#集合处理\"}},[t._v(\"#\")]),t._v(\" 集合处理\")]),t._v(\" \"),o(\"ol\",[o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 关于hashCode和equals的处理，遵循如下规则：\\n\"),o(\"ul\",[o(\"li\",[t._v(\"只要重写equals，就必须重写hashCode\")]),t._v(\" \"),o(\"li\",[t._v(\"因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储对象必须重写这两个方法\")]),t._v(\" \"),o(\"li\",[t._v(\"如果自定义对象作为Map的键，就必须重写hashCode和equals方法\")])])],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" ArrayList的subList结果不可强转为ArrayList，否则会抛出类造型异常\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 在subList场景中，高度注意对原集合元素的增加和删除，均会导致子列表的遍历、增加、删除产生异常\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一样的数组\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，否则会抛出异常\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 泛型通配符<? extens T>来接收返回的数据，此写法的泛型集合不能使用add方法，而<?  super T>不\\n能使用get方法，作为接口调用赋值时易出错\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 不要再foreach循环里对元素进行add/remove操作，remove元素请使用Iterator方法，如果并发操作，\\n需对Iterator对象加锁\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 在JDK7版本及以上，Comparator实现类要满足如下三个条件，不然Arrays.sort，Collection.sort\\n会报 IllegalArgumentException 异常\\n\"),o(\"ul\",[o(\"li\",[t._v(\"x,y比较结果和y，x比较结果相反\")]),t._v(\" \"),o(\"li\",[t._v(\"x > y, y > z,则x > z\")]),t._v(\" \"),o(\"li\",[t._v(\"x = y,则x，z比较结果和y，z比较结果相同\")])])],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 集合泛型定义时，在JDK7及以上，使用diamond语法或全省略\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 集合初始化时，指定初始化值大小\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 使用entrySet遍历Map类集合KV，而不是keySet方式进行遍历\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"green\"}},[t._v(\"[参考]\")]),t._v(\" 合理利用好集合的稳定性和有序性，比较集合的无序性和不稳定性带来的影响\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"green\"}},[t._v(\"[参考]\")]),t._v(\" 利用Set元素唯一的特性，可以快速对集合进行去重，避免使用List的contains方法进行遍历、对比、去\\n重操作\")],1)]),t._v(\" \"),o(\"hr\"),t._v(\" \"),o(\"h2\",{attrs:{id:\"并发处理\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#并发处理\"}},[t._v(\"#\")]),t._v(\" 并发处理\")]),t._v(\" \"),o(\"ol\",[o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 获取单例对象需要保证线程安全，其中的方法也要保证线程安全\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 线程资源必须通过线程池提供，不允许在应用中自行显示创建线程\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 线程池不允许使用Executors去创建，而是通过ThreadPoolExecutors的方式，这样的处理方式让写的\\n同学更加明确线程池的运行规则，规避资源耗尽的风险\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" SimpleDataFormat是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，\\n或者使用DateUtils工具类\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 高并发时，同步调用应该去考量锁的性能消耗。能使用无锁数据结构，就不要用锁；能锁区块，就不要锁整\\n个方法体，能用对象锁，就不要使用类锁\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 并发修改同一记录时，避免更新丢失，需要加锁\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其他任务\\n便会自动终止运行，使用ScheduledExecutorService则没有这个问题\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注\\n意catch异常，确保countDown方法执行到，避免主线程无法执行到await方法，直到超时才返回结果\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed导致性能下降\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(' 在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优 化问题隐患(可参\\n考 The \"Double-Checked Locking is Broken\" Declaration)，推荐解 决方案中较为简单一种(适用于 JDK5 及以上版本)，将目标属性声明为 volatile 型')],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"green\"}},[t._v(\"[参考]\")]),t._v(\" volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题， 但是如果多写，同样\\n无法解决线程安全问题\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在 开发过程中可以使\\n用其它数据结构或加锁来规避此风险\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static 修饰\")],1)]),t._v(\" \"),o(\"hr\"),t._v(\" \"),o(\"h2\",{attrs:{id:\"控制语句\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#控制语句\"}},[t._v(\"#\")]),t._v(\" 控制语句\")]),t._v(\" \"),o(\"ol\",[o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将执行到哪一个case\\n位置；在一个switch块内，都必须包含一个default语句并且放在最后，即使空代码\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 在if/else/for/while/do语句中必须使用大括号，即使只有一行代码\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(' 在高并发场景中，避免使用\"等于\"判断作为中断或退出的条件')],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 表达异常的分支时，少用if-else方式\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 除常用方法(如getXxx/isXxx)等外，不要在条件判断中执行其他复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的try-catch操作\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 避免采用取反逻辑运算符\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 接口入参保护，这种场景常用的是用作批量操作的接口\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"green\"}},[t._v(\"[参考]\")]),t._v(\" 下列情形，需要进行参数校验：\\n\"),o(\"ul\",[o(\"li\",[t._v(\"用频次低的方法\")]),t._v(\" \"),o(\"li\",[t._v(\"执行时间开销很大的方法\")]),t._v(\" \"),o(\"li\",[t._v(\"需要极高稳定性和可用性的方法\")]),t._v(\" \"),o(\"li\",[t._v(\"对外提供的开放接口，不管是RPC/API/HTTP接口\")]),t._v(\" \"),o(\"li\",[t._v(\"敏感权限入口\")])])],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 下列情形，不需要进行参数校验\\n\"),o(\"ul\",[o(\"li\",[t._v(\"极有可能被循环调用的方法\")]),t._v(\" \"),o(\"li\",[t._v(\"底层调用频度较高的方法\")]),t._v(\" \"),o(\"li\",[t._v(\"被声明成private只会被自己代码调用的方法\")])])],1)]),t._v(\" \"),o(\"hr\"),t._v(\" \"),o(\"h2\",{attrs:{id:\"注释规约\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#注释规约\"}},[t._v(\"#\")]),t._v(\" 注释规约\")]),t._v(\" \"),o(\"ol\",[o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 类、类属性、类方法的注释必须使用Javadoc规范\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 所有的抽象方法(包括接口中的方法)必须要用Javadoc注释\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 所有的类都必须添加创建者和创建日期\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 方法内部单行注释，在被注释语句上方另起一行，使用//注释,方法内部多行注释用/* */\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 所有的枚举类型字段必须要有注释，说明每个数据项的用途\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(' 与其\"半吊子\"英文来注释，不如用中文注释把问题说清楚')],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 代码修改的同时，注释也要进行相应的修改\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"green\"}},[t._v(\"[参考]\")]),t._v(\" 谨慎注释掉代码\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"green\"}},[t._v(\"[参考]\")]),t._v(\" 对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含 义，使别的程序员能够迅速了解到代码背后的信息\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"green\"}},[t._v(\"[参考]\")]),t._v(\" 好的命名、代码结构是自解释的，注释力求精简准确、表达到位\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"green\"}},[t._v(\"[参考]\")]),t._v(\" 特殊注释标记，请注明标记人和标记时间\")],1)]),t._v(\" \"),o(\"hr\"),t._v(\" \"),o(\"h2\",{attrs:{id:\"其他\"}},[o(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#其他\"}},[t._v(\"#\")]),t._v(\" 其他\")]),t._v(\" \"),o(\"ol\",[o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 在使用正则表达式时，利用好其预编译功能，可以有效地加快正则匹配速度\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" velocity调用POJO类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用POJO的getXxx(),如果是boolean基本数据类型变量(boolean命名不需要加is前缀)，会自动调用isXxx()方法\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 后台输送给页面的变量必须加$!{var}中间的感叹号\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 注意Math.random()这个方法返回的是double类型，注意取值的范围0≤x＜1(能够取到零值，注意除零异常)，如果想获取整数类型的随机数，直接使用Random对象的nextInt或者nextLong方法\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"red\"}},[t._v(\"[强制]\")]),t._v(\" 获取当前毫秒数System.currentTimeMillis()，而不是new Date().getTime()\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 不要在视图模板中加入任何复杂的逻辑\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 任何数据结构的构造和初始化，都应指定大小，避免数据结构无限增长吃光内存\")],1),t._v(\" \"),o(\"li\",[o(\"font\",{attrs:{color:\"orange\"}},[t._v(\"[推荐]\")]),t._v(\" 及时清理不再使用的代码或配置信息\")],1)])])}),[],!1,null,null,null);v.default=_.exports}}]);","extractedComments":[]}