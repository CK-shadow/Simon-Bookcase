---
title: 抽象工厂模式
tags: 
 - 设计模式
 - 抽象工厂模式
categories: frontEnd
---

>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类

## 抽象工厂模式
![](../../.vuepress/public/img/202004021410.png)  
AbstractFactory是抽象工厂接口，里面包含所有的产品创建的抽象方法；ConcreteFactory则是具体的工厂，创建具有特定实现的产品对象；AbstractProduct是抽象产品，有可能由两种不同的实现；ConcreteProduct则是对于抽象产品的具体分类的实现

&emsp;  
1. **何时使用**  
系统的产品有多于一个的产品族，而系统只消费其中某一族的产品时
2. **优点**  
   * 封装性，易于产品交换。由于具体工厂类在一个应用中只需在初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，只需改变具体工程即可使用不同的产品配置
   * 创建实例过程与客户端分离
3. **缺点**  
产品族扩展非常困难，改动或增加一个产品需同时改动多个类
4. **使用场景**  
一个对象族（或一组没有任何关系的对象）都有相同的约束

## 工厂方法模式的实现
在看抽象工厂模式之前，我们先用工厂方法模式试一下  
![](../../.vuepress/public/img/202004021745.png)  
### IFactory接口
```java
public interface IFactory {
    IUser createUser();   
    IDepartment createDepartment();
}
```

### IDepartment接口
```java
public interface IDepartment {
    public void insert(Department department);
    public Department getDepartment(int id);
}
```

### 数据库工厂
```java
public class SqlserverFactory implements IFactory {

    @Override
    public IUser createUser() {
        return new SqlserverUser();
    }

    @Override
    public IDepartment createDepartment() {
        return new SqlserverDepartment();
    }

}
```

### IDepartment接口的实现类
```java
public class SqlserverDepartment implements IDepartment {

    @Override
    public void insert(Department department) {
        System.out.println("insert info into department with sqlserver");
    }

    @Override
    public Department getDepartment(int id) {
        System.out.println("get info from department by id with sqlserver");
        return null;
    }

}
```

### Client客户端
```java
public class Client {
    
    public static void main(String[] args) {
        User user = new User();
        Department department = new Department();
        
        IFactory factory = new SqlserverFactory();
//        IFactory factory = new AccessFactory();
        
        IUser iUser = factory.createUser();
        iUser.insert(user);
        iUser.getUser(1);
        
        IDepartment iDepartment = factory.createDepartment();
        iDepartment.insert(department);
        iDepartment.getDepartment(1);
    }

}
```
刚才我们只有一个User类和User操作类的时候，只需要工厂方法模式即可，但现在显然数据库中有许多的表，而SQLServer和Access又是两个不同的分类，解决这种涉及到多个产品系列的问题，就用到了抽象工厂模式