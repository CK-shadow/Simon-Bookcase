---
title: 命令模式
tags: 
 - 设计模式
 - 命令模式
categories: frontEnd
---

>将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作

## 命令模式
1. **意图**  
将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化
2. **主要解决**  
在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适
3. **何时使用**  
在某些场合，比如要对行为进行"记录、撤销/重做、事务"等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将"行为请求者"与"行为实现者"解耦？将一组行为抽象为对象，可以实现二者之间的松耦合
4. **如何解决**  
通过调用者调用接受者执行命令，顺序：调用者→接受者→命令
5. **关键代码**  
定义三个角色：
   * received 真正的命令执行对象 
   * Command 
   * invoker 使用命令对象的入口
6. **优点**  
   * 降低了系统耦合度
   * 新的命令可以很容易添加到系统中去
7. **缺点**  
使用命令模式可能会导致某些系统有过多的具体命令类
8. **注意事项**  
系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展

## 命令模式的实现
以烧烤店模型为例，使用命令模式编写代码实现  
![](../../.vuepress/public/img/202004071121.png)  
### 调用者角色
服务员类为调用者角色，在其中定义一个订单列表用于存储客户订单信息，通过setOrder()方法设置订单、cancelOrder()方法取消订单、notifyExecute()方法下单
```java
public class Waiter {

    private List<Command> orders = new LinkedList<>();
    
    //设置订单
    public void setOrder(Command command) throws Exception {
        //通过反射获得鸡翅的类
        String s1 = Class.forName("com.adamjwh.gofex.command.BakeChickenWingCommand").toString().substring(6);
        //获取command订单中的类
        String s2 = command.toString().substring(0, command.toString().indexOf("@"));
        
        //这里模拟鸡翅卖完的情况，当订单中有鸡翅时，撤销订单
        if(s1.equals(s2)) {
            System.out.println("【服务员：鸡翅没有了，请点别的烧烤】");
            cancelOrder(command);//撤销订单
        } else {
            orders.add(command);
            System.out.println("添加订单：" + command.getBarbecuer() + "\t时间：" + new Date().toString());
        }
    }
    
    //取消订单
    public void cancelOrder(Command command) {
        orders.remove(command);
        System.out.println("取消订单：" + command.getBarbecuer() + "\t时间：" + new Date().toString());
    }
    
    //通知全部执行
    public void notifyExecute() {
        System.out.println("-----------------------订单-----------------------");
        for(Command command : orders) {
            command.excuteCommand();
        }
    }
}
```

### 命令角色
```java
public abstract class Command {

    protected Barbecuer receiver;
    
    public Command(Barbecuer receiver) {
        this.receiver = receiver;
    }
    
    //执行命令
    abstract public void excuteCommand();
    
    //获取名称
    abstract public String getBarbecuer();
    
}
```

### 接收者角色
这里的接收者角色就是烧烤师傅，提供“烤羊肉串”和“烤鸡翅”的操作
```java
public class Barbecuer {
    
    //烤羊肉
    public void bakeMutton() {
        System.out.println("烤羊肉串");
    }
    
    //烤鸡翅
    public void bakeChickenWing() {
        System.out.println("烤鸡翅");
    }
    
}
```

### 具体命令
这里以烤羊肉串类为例，提供了执行命令的方法。烤鸡翅类同理，此处不再赘述
```java
public class BakeMuttonCommand extends Command {

    private String barbecuer;
    
    public BakeMuttonCommand(Barbecuer receiver) {
        super(receiver);
        barbecuer = "烤羊肉串";
    }

    @Override
    public void excuteCommand() {
        receiver.bakeMutton();
    }
    
    //获取名称
    public String getBarbecuer() {
        return barbecuer;
    }
    
}
```

### 测试代码
开店前准备即初始化烤肉师傅、服务员及命令类，顾客点菜后将菜单信息存入服务员的订单上，假设鸡翅卖完了（参考Waiter类），则将鸡翅项从订单上删除（即“撤销”），然后使用notifyExecute()方法通知烤肉师傅
```java
public class Client {

    public static void main(String[] args) throws Exception {
        //开店前准备
        Barbecuer barbecuer = new Barbecuer();
        Command bakeMuttonCommand1 = new BakeMuttonCommand(barbecuer);
        Command bakeMuttonCommand2 = new BakeMuttonCommand(barbecuer);
        Command bakeChickenWingCommand1 = new BakeChickenWingCommand(barbecuer);
        Waiter waiter = new Waiter();
        
        //开门营业，顾客点菜
        waiter.setOrder(bakeMuttonCommand1);
        waiter.setOrder(bakeMuttonCommand2);
        //这里假设鸡翅卖完了
        waiter.setOrder(bakeChickenWingCommand1);
        
        //点菜完毕，通知厨房
        waiter.notifyExecute();
    }
    
}
```