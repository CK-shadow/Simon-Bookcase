---
title: 策略模式
tags: 
 - 设计模式
 - 策略模式
categories: frontEnd
---

## 设计原则
【设计原则1】：**找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起**  
把会变化的部分取出并封装起来，以便以后可以轻易地改动或扩展此部分，而不影响不需要变化的其他部分

&emsp;  
【设计原则2】：**针对接口编程，而不是针对实现编程**  
针对接口编程真正的意思是：针对超类型（supertype）编程  

&emsp;  
针对实现编程：
```java
Dog dog = new Dog();
dog.bark();
```
针对接口编程
```java
Animal dog = new Dog();
dog.bark();
```
这样可以在运行时才指定具体实现的对象

&emsp;  
【设计原则3】：**多用组合，少用继承**  
利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为；而利用组合的做法扩展对象的行为，就可以在运行时动态地进行扩展  

使用组合建立系统具有很大的弹性，不仅可将算法族封装成类，更可以"在运行时动态地改变行为"，只要组合的行为对象符合正确的接口标准即可  

类之间的关系可以描述为：IS-A（是一个，组合过来的-|>）、HAS-A（有一个，继承过来的->）和IMPLEMENTS（实现，接口的实现....|>)

## 策略模式
![](../../.vuepress/public/img/202003291326.png)   
1. **何时使用**  
一个系统有许多类，而区分它们的只是他们直接的行为时
2. **方法**  
将这些算法封装成一个一个的类，任意的替换
3. **关键代码**  
实现同一个接口
4. **优点**  
   * 算法可以自己的切换
   * 避免使用多重条件判断（如果不用策略模式我们可能会使用多重条件语句，不利于维护）
   * 扩展性良好，增加一个策略只需实现接口即可
5. **缺点**   
   * 策略类数量会增多，每个策略都是一个类，复用的可能性很小
   * 所有的策略类都需要对外暴露
6. **使用场景**  
   * 多个类只有算法或行为上稍有不同的场景
   * 算法需要自由切换的场景
   * 需要屏蔽算法规则的场景
7. **注意事项**  
如果一个系统的策略多于四个，就需要考虑使用混合模式来解决策略类膨胀的问题