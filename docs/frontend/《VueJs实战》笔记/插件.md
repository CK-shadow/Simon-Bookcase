---
title: 插件
tags: 
 - Vue.js
categories: frontEnd
---

注册插件需要一个公开的方法install，它的第一个参数是Vue构造器，第二个参数是一个可选的选项对象。示例代码如下：
```js
MyPlugin.install = function (Vue, options) {
    // 全局注册组件（指令等功能资源类似）
    Vue.component('component-name', {
        // 组件内容
    }),
    // 添加实例方法
    Vue.prototype.$Notice = function () {
        // 逻辑 ...
    },
    // 添加全局方法或属性
    Vue.globalMethod = function () {
        // 逻辑 ...
    },
    // 添加全局混合
    Vue.mixin({
        mounted: function () {
            // 逻辑 ...
        }
    })
}
```
通过Vue.use()来使用插件：
```js
Vue.use(MyPlugin)
或
Vue.use(MyPlugin, {
    // 参数
})
```
绝大多数情况下，开发插件主要是通过NPM发布后给别人使用的，在自己的项目中可以直接在入口调用以上的方法，无须多一步注册和使用的步骤

## 前端路由与vue-router
### 什么是前端路由
前端路由，即由前端来维护一个路由规则。实现有两种，一种是利用url的hash，就是常说的锚点（#），JavaScript通过hashChange事件来监听url的改变，IE7及以下需要用轮询；另一种就是HTML5的history模式，它使url看起来像普通网站那样，以"/"分割，没有#，但页面并没有跳转，不过使用这种模式需要服务端支持，服务端在接收到所有的请求后，都指向同一个html文件，否则会出现404.因此，SPA只有一个html，整个网站的所有内容都在这一个html里，通过JavaScript来处理

### vue-router基本用法
新建一个目录Router，复制Demo代码并安装完成后，再通过NPM来安装vue-router
```
npm install --save vue-router
```
在main.js里使用Vue.use()加载插件
```js
import Vue from 'vue';
import App from './app.vue';
import VueRouter from 'vue-router';

Vue.use(VueRouter);
```
每个页面对应一个组件，也就是对应一个.vue文件。在Router目录下创建views目录，用于存放所有的页面然后在views里创建index.vue和about.vue两个文件
```vue
<!-- index.vue -->
<template>
    <div>首页</div>
</template>

<script>
    export default {
    }
</script>
```
```vue
<!-- about.vue -->
<template>
    <div>介绍页</div>
</template>

<script>
    export default {
    }
</script>
```
再回到main.js里，完成路由的剩余配置。创建一个数组来制定路由匹配列表，每一个路由映射一个组件
```js
const Routers = [
    {
        path: '/index',
        component: (resolve) => require(['./views/index.vue'], resolve)
    },
    {
        path: '/about',
        component: (resolve) => require(['./views/baout.vue'], resolve)
    }
];
```
Routers里的每一项path属性就是指定当前匹配的路径，component是映射的组件。上例的写法，webpack会把每一个路由都打包为一个js文件，在请求到该页面时，才去加载这个页面的js，也就是异步实现的懒加载（按需加载）。这样做的好处是不需要在打开首页的时候就把所有的页面内容全部加载进来，只在访问时才加载。如果非要一次性加载，可以这样写：
```js
{
    path: '/index',
    component: require('./views/index.vue')
}
```
然后继续在main.js里完成配置和路由实例
```js
const RouterConfig = {
    // 使用HTML5的history模式
    mode: 'history',
    routes: Routers
};

new Vue({
    el: '#app',
    router: router,
    render: h => {
        return h(App)
    }
});
```
在RouterConfig里，设置mode为history会开启HTML5的History路由模式，通过"/"设置路径。如果不设置mode，就会使用"#"来设置路径。开启History路由，在生产环境时服务端必须进行配置，讲所有路由都指向同一个html，或设置404页面为该html，否则刷新页面时会出现404

&emsp;  
webpack-dev-server也要配置下来支持History路由，在package.json中修改dev命令：
```json
"scripts": {
    "dev": "webpack-dev-server --open --history-api-fallback --config webpack.config.js"
}
```
增加了--history-api-fallback，所有的路由都会指向index.html

&emsp;  
配置好了这些，最后在根实例app.vue里添加一个路由视图router-view来挂载所有的路由组件
```vue
<template>
    <div>
        <router-view></router-view>
    </div>
</template>
<script>
    export default {

    }
</script>
```
运行网页时，router-view会根据当前路由动态渲染不同的页面组件。网页中一些公共部分，比如顶部的导航栏、侧边导航栏、底部的版权信息，这些也可以直接写在app.vue里，与router-view同级。路由切换时，切换的是router-view挂载的组件，其它的内容不会变化

&emsp;  
运行npm run dev启动服务，然后访问localhost:8080/index和localhost:8080/about就可以访问这两个页面了

&emsp;  
在路由列表里，可以在最后新加一项，当访问的路径不存在时，重定向到首页
```js
const Routers = [
    // ...
    {
        path: '*',
        redirect: '/index'
    }
];
```
这样直接访问localhost:8080，就跳转到了localhost:8080/index页面

&emsp;  
路由列表的path也可以带属性，比如“个人主页”场景，路由的一部分是固定的，一部分是动态的：/user/123456，其中用户id“123456”就是动态的，但它们路由到同一个页面，在这个页面里，期望获取这个id，然后请求相关数据。在路由里可以这样配置参数
```js
// main.js
const Router = [
    // ...
    {
        path: 'user/:id',
        component: (resolve) => require(['./views/user.vue'], resolve)
    }
]
```
```vue
// 在router/views目录下，新建user.vue文件
<template>
    <div>{{ $route.params.id }}</div>
</template>
<script>
    export default {
        mounted () {
            console.log(this.$route.params.id);
        }
    }
</script>
```
因为配置的路由是"/user/:id"，所以直接访问localhost:8080/user回重定向到index页面，需要带一个id才能跳转到user页面，比如localhost:8080/user/123456

### 跳转
vue-router有两种跳转页面的作用，第一种是使用内置的router-link组件，它会被渲染为一个a标签：
```vue
// index.vue
<template>
    <div>
        <h1>首页</h1>
        <router-link to="/about">跳转到about</router-link>
    </div>
</template>
```
它的用法与一般的组件一样，to是一个prop，指定需要跳转的路径，当然也可以用v-bind动态设置。使用router-link，在HTML5的History模式下会拦截点击，避免浏览器重新加载页面

&emsp;  
router-link还有其它的一些prop，常用的有：  
* tag  
  tag可以指定渲染成什么标签，比如在router-link中添加tag="li"，渲染的结果解时li而不是a标签
* replace  
  使用replace不会留下History记录，所以导航后不能用后退键返回上一个页面
* active-class  
  当router-link对应的路由匹配成功时，会自动给当前元素设置一个名为router-link-active的class，设置prop：active-class可以修改默认的名称。在做类似导航栏时，可以使用该功能高亮显示当前页面对应的导航菜单项，但是一般不会修改active-class，直接使用默认值router-link-active即可

&emsp;  
有时候，跳转页面可能需要在JavaScript里进行，类似于window.location.href。这时可以用第二种跳转方法，使用router实例的方法。比如在about.vue中，通过点击事件跳转：
```vue
// about.vue
<template>
    <div>
        <h1>介绍页</h1>
        <button @click="handleRouter">跳转到user<button>
    </div>
</template>
<script>
    export default {
        methods: {
            handleRouter () {
                this.$router.push('/user/123');
            }
        }
    }
</script>
```
$router还有一些其它方法：
* replace  
  类似于router-link的replace功能，它不会向History添加新记录，而是替换掉当前的记录
* go  
  类似于window.history.go()，在History的记录中向前或后退多少步，参数是整数

### 高级用法
**修改页面标题**  
比较理想的一个思路就是，在页面发生路由改变时，统一设置。vue-router提供了导航钩子，beforeEach和afterEach，它们会在路由即将改变前和改变后触发，所以设置标题可以在beforeEach钩子完成
```js
// main.js
const Routers = [
    {
        path: '/index',
        meta: {
            title: '首页'
        },
        component: (resolve) => require(['./views/index.vue'], resolve)
    },
    {
        path: '/about',
        meta: {
            title: '关于'
        },
        component: (resolve) => require(['./views/about.vue'], resolve)
    }
];

const Router = new VueRouter(RouterConfig);
router.beforeEach((to, from, next) => {
    window.document.title = to.meta.title;
    next();
});
```
导航钩子有3个函数：
* to 即将要进入的目标的路由对象
* from 当前导航即将要离开的路由对象
* next 调用该方法后，才能进入下一个钩子

路由列表的meta字段可以自定义一些信息，比如我们将每个页面的title写入了meta来统一维护，beforeEach钩子可以从路由对象to里获取meta消息，从而改变标题

&emsp;  
**跳转页面返回顶端**  
比如一个页面较长，滚动到某个位置，再跳转到另一个页面，滚动条默认是上一个页面停留的位置，而好的体验肯定时能返回顶端。通过钩子函数afterEach就可以实现：
```js
// main.js
// ...
router.afterEach((to, from, next) => {
    window.scrollTo(0, 0);
});
```
类似的需求还有，从一个页面过渡到另一个页面时，可以出现一个全局的Loading动画，等到新页面加载完成后再结束动画

&emsp;  
**登录校验**  
某些页面需要校验是否登录，如果登录了就可以访问，否则跳转到登录页。这里我们通过localStorage来简易判断是否登录，示例代码如下：
```js
router.beforeEach((to, from, next) => {
    if (window.localStorage.getItem('token')) {
        next();
    } else {
        next('/login');
    }
});
```
next()的参数设置为false时，可以取消导航，设置为具体的路径可以导航到指定页面